using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace FlowWire.Framework.Analyzers.Generators;

[Generator]
public class DriverGenerator : IIncrementalGenerator
{
    private const int MaxGenericParameters = 8;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var interfaces = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsCandidate(node),
                transform: static (ctx, _) => GetInterfaceModel(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(interfaces, static (spc, source) => Execute(spc, source!));
    }

    private static bool IsCandidate(SyntaxNode node)
    {
        return node is InterfaceDeclarationSyntax i && i.AttributeLists.Count > 0;
    }

    private static ActivityInterfaceModel? GetInterfaceModel(GeneratorSyntaxContext context)
    {
        var interfaceDecl = (InterfaceDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(interfaceDecl);

        if (symbol is null || !IsDriver(symbol))
        {
            return null;
        }

        var methods = ImmutableArray.CreateBuilder<ActivityMethodModel>();
        ScanInterface(symbol, methods);

        return new ActivityInterfaceModel(
            symbol.ContainingNamespace.ToDisplayString(),
            symbol.Name,
            new EquatableArray<ActivityMethodModel>(methods.ToImmutable())
        );
    }

    private static void ScanInterface(INamedTypeSymbol symbol, ImmutableArray<ActivityMethodModel>.Builder methods)
    {
        foreach (var member in symbol.GetMembers().OfType<IMethodSymbol>())
        {
            methods.Add(GetMethodModel(member));
        }
    }

    private static bool IsDriver(INamedTypeSymbol symbol)
    {
        return symbol.GetAttributes().Any(static a =>
            a.AttributeClass?.ToDisplayString() == "FlowWire.Framework.Abstractions.DriverAttribute");
    }

    private static ActivityMethodModel GetMethodModel(IMethodSymbol method)
    {
        var parameters = ImmutableArray.CreateBuilder<ActivityParameterModel>();
        foreach (var p in method.Parameters)
        {
            parameters.Add(new ActivityParameterModel(
                p.Name,
                p.Type.ToDisplayString(),
                false // Removed IsInject check
            ));
        }

        var returnType = "FlowCommand";
        string? innerReturnType = null;

        if (method.ReturnType is INamedTypeSymbol taskType && taskType.IsGenericType)
        {
            // Task<T> -> extract T
            innerReturnType = taskType.TypeArguments[0].ToDisplayString();
            returnType = $"DriverCommand<{innerReturnType}>";
        }

        return new ActivityMethodModel(
            method.Name,
            returnType,
            innerReturnType,
            new EquatableArray<ActivityParameterModel>(parameters.ToImmutable())
        );
    }

    private static void Execute(SourceProductionContext context, ActivityInterfaceModel model)
    {
        var sb = new StringBuilder();
        
        AppendFileHeader(sb, model);
        AppendClassDefinition(sb, model);

        foreach (var method in model.Methods)
        {
            AppendMethod(sb, method);
        }

        sb.AppendLine("}");

        context.AddSource($"{model.InterfaceName}_Driver.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void AppendFileHeader(StringBuilder sb, ActivityInterfaceModel model)
    {
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using FlowWire.Framework.Abstractions;");
        sb.AppendLine($"namespace {model.Namespace};");
        sb.AppendLine();
    }

    private static void AppendClassDefinition(StringBuilder sb, ActivityInterfaceModel model)
    {
        sb.AppendLine($"public class {model.InterfaceName}_Driver");
        sb.AppendLine("{");
        sb.AppendLine("    private readonly DriverProxy _proxy;");
        sb.AppendLine();
        sb.AppendLine($"    public {model.InterfaceName}_Driver(DriverProxy proxy)");
        sb.AppendLine("    {");
        sb.AppendLine("        _proxy = proxy;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void AppendMethod(StringBuilder sb, ActivityMethodModel method)
    {
        var clientParams = method.Parameters.Select(p => $"{p.Type} {p.Name}");
        var args = string.Join(", ", clientParams);

        var passThroughParams = method.Parameters.Select(p => p.Name);
        var passThroughArgs = string.Join(", ", passThroughParams);
        if (!string.IsNullOrEmpty(passThroughArgs))
        {
            passThroughArgs = ", " + passThroughArgs;
        }

        sb.AppendLine($"    public {method.ReturnType} {method.Name}({args})");
        sb.AppendLine("    {");
        sb.Append("        return _proxy.Drive");
        
        // Optimization: Use generic Run to avoid boxing the return type wrapper and enable inference
        if (method.InnerReturnType != null)
        {
            sb.Append($"<{method.InnerReturnType}");
            
            // If the parameter count is <= MaxGenericParameters, we can use the generic overload which includes argument types
            if (method.Parameters.Count() <= MaxGenericParameters)
            {
                foreach (var p in method.Parameters)
                {
                    sb.Append($", {p.Type}");
                }
            }
            sb.Append('>');
        }
        
        sb.AppendLine($"(\"{method.Name}\"{passThroughArgs});");
        sb.AppendLine("    }");
        sb.AppendLine();
    }
}

