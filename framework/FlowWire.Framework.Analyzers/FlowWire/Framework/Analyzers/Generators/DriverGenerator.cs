using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace FlowWire.Framework.Analyzers.Generators;

[Generator]
public class DriverGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var interfaces = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsCandidate(node),
                transform: static (ctx, _) => GetInterfaceModel(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(interfaces, static (spc, source) => Execute(spc, source!));
    }

    private static bool IsCandidate(SyntaxNode node)
    {
        return node is InterfaceDeclarationSyntax i && i.AttributeLists.Count > 0;
    }

    private static ActivityInterfaceModel? GetInterfaceModel(GeneratorSyntaxContext context)
    {
        var interfaceDecl = (InterfaceDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(interfaceDecl);

        if (symbol is null || !IsDriver(symbol))
        {
            return null;
        }

        var methods = ImmutableArray.CreateBuilder<ActivityMethodModel>();

        foreach (var member in symbol.GetMembers().OfType<IMethodSymbol>())
        {
            methods.Add(GetMethodModel(member));
        }

        return new ActivityInterfaceModel(
            symbol.ContainingNamespace.ToDisplayString(),
            symbol.Name,
            new EquatableArray<ActivityMethodModel>(methods.ToImmutable())
        );
    }

    private static bool IsDriver(INamedTypeSymbol symbol)
    {
        return symbol.GetAttributes().Any(static a =>
            a.AttributeClass?.ToDisplayString() == "FlowWire.Framework.Abstractions.DriverAttribute");
    }

    private static ActivityMethodModel GetMethodModel(IMethodSymbol method)
    {
        var parameters = ImmutableArray.CreateBuilder<ActivityParameterModel>();
        foreach (var p in method.Parameters)
        {
            parameters.Add(new ActivityParameterModel(
                p.Name,
                p.Type.ToDisplayString(),
                false // Removed IsInject check
            ));
        }

        var returnType = "FlowCommand";
        string? innerReturnType = null;

        if (method.ReturnType is INamedTypeSymbol taskType && taskType.IsGenericType)
        {
            // Task<T> -> extract T
            innerReturnType = taskType.TypeArguments[0].ToDisplayString();
            returnType = $"DriverCommand<{innerReturnType}>";
        }

        return new ActivityMethodModel(
            method.Name,
            returnType,
            innerReturnType,
            new EquatableArray<ActivityParameterModel>(parameters.ToImmutable())
        );
    }

    private static void Execute(SourceProductionContext context, ActivityInterfaceModel model)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using FlowWire.Framework.Abstractions;");
        sb.AppendLine($"namespace {model.Namespace};");
        sb.AppendLine();
        sb.AppendLine($"public class {model.InterfaceName}_Driver");
        sb.AppendLine("{");
        
        sb.AppendLine("    private readonly DriverProxy _proxy;");
        sb.AppendLine();
        sb.AppendLine($"    public {model.InterfaceName}_Driver(DriverProxy proxy)");
        sb.AppendLine("    {");
        sb.AppendLine("        _proxy = proxy;");
        sb.AppendLine("    }");
        sb.AppendLine();

        foreach (var method in model.Methods)
        {
            var clientParams = method.Parameters
                .Select(p => $"{p.Type} {p.Name}");

            var args = string.Join(", ", clientParams);

            var passThroughParams = method.Parameters
                .Select(p => p.Name);

            var passThroughArgs = string.Join(", ", passThroughParams);
            if (!string.IsNullOrEmpty(passThroughArgs))
            {
                passThroughArgs = ", " + passThroughArgs;
            }

            sb.AppendLine($"    public {method.ReturnType} {method.Name}({args})");
            sb.AppendLine("    {");

            sb.Append("        return _proxy.Drive");
            
            // Optimization: Use generic Run to avoid boxing the return type wrapper and enable inference
            if (method.InnerReturnType != null)
            {
                sb.Append($"<{method.InnerReturnType}");
                
                // If the parameter count is <= 8, we can use the generic overload which includes argument types
                if (method.Parameters.Count() <= 8)
                {
                    foreach (var p in method.Parameters)
                    {
                        sb.Append($", {p.Type}");
                    }
                }
                sb.Append(">");
            }
            
            sb.AppendLine($"(\"{method.Name}\"{passThroughArgs});");

            sb.AppendLine("    }");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        context.AddSource($"{model.InterfaceName}_Driver.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}

internal record ActivityInterfaceModel(string Namespace, string InterfaceName, EquatableArray<ActivityMethodModel> Methods);
internal record ActivityMethodModel(string Name, string ReturnType, string? InnerReturnType, EquatableArray<ActivityParameterModel> Parameters);
internal record ActivityParameterModel(string Name, string Type, bool IsInjected);

/// <summary>
/// A wrapper for ImmutableArray that implements value equality for correct incremental caching.
/// </summary>
readonly internal struct EquatableArray<T>(ImmutableArray<T> array) : IEquatable<EquatableArray<T>>, IEnumerable<T>
{
    private readonly ImmutableArray<T> _array = array;

    public bool Equals(EquatableArray<T> other)
    {
        return _array.SequenceEqual(other._array);
    }

    public override bool Equals(object? obj)
    {
        return obj is EquatableArray<T> other && Equals(other);
    }

    public override int GetHashCode()
    {
        var hash = 17;
        foreach (var item in _array)
        {
            hash = hash * 31 + (item?.GetHashCode() ?? 0);
        }
        return hash;
    }

    public IEnumerator<T> GetEnumerator()
    {
        IEnumerable<T> collection = _array.IsDefault ? [] : _array;
        return collection.GetEnumerator();
    }

    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}

